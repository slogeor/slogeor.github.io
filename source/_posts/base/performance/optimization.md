---
title: 性能优化
categories: base
tags: #文章標籤 可以省略
  - performance
---

### 前言

随着4G的推广，网速越来越快，PC站好像不是特别care性能，因为网速已经够快，基本可以忽略。但流量就是金钱，由此看来性能优化还是很有必要的。常规的web前端性能优化大家都会谈到雅虎的34条军规，如还不了解，先去Google吧

当我们在浏览器输入`www.google.com`到最后页面呈现出来，背后都发生那么些神秘的动作。

`解析URL` —> `检查HSTS列表` —> `DNS查询`  —> `HTTP请求`—-> `浏览器获取数据` —> `HTML解析` —> `CSS解析` —> `页面渲染` —> `GPU渲染` —> `JavaScript渲染`

我们可以对上面解析过程进行分为三个层次(主要是为了方便进行性能分析)，浏览器层面、传输层面、执行层面。下面会从这三个层面进行性能分析

- 浏览器层面：用户在浏览器输入要访问的网址，本地DNS请求网站授权的DNS服务器对域名进行解析得到 IP 地址后（并将IP地址缓存起来），浏览器向目标IP地址发出请求。在域名解析之前，浏览器是不会下载任何资源
- 传输层面：向服务端请求各种资源，服务端根据用户的请求将需要的资源返回给浏览器
- 执行层面：浏览器得到各种资源后进行页面渲染

### 页面渲染

网页是自上而下解析渲染，边解析边渲染（页面内CSS文件会阻塞渲染，异步CSS文件会导致回流），浏览器在document下载结束会检测静态资源，新开线程下载（有并发上限），在带宽限制的条件下，无序并发会导致主资源速度下降，从而影响首屏渲染

### 考核指标

- 2g网络：X秒内完成dns查询、和后台服务器建立连接
- 3g网络：X秒内完成首字显示（首字时间）
- wifi网络：X秒内完成首屏显示（首屏时间）

### 分析指标

- 浏览器层面：通过预加载，减少DNS解析时间
- 传输层面：减少请求数，降低请求量
- 执行层面：减少重绘、回流，删除冗余代码、资源本地化

**<font color="blue">1、浏览器层面</font>**

对支持预加载特性的浏览器可以使用预加载技术，减少DNS查询时间

- DNS查询

描述：DNS查询是有代价的，浏览器会根据给定的域名用DNS查询IP地址，这一操作通常需要花费20-120ms，且在DNS查询未完成之前浏览器不会下载任何资源

优点：同域名浏览器并行下载数量有限，通过增加域名可以提高并行下载数量

缺点：减少域名的数量可以缩短DNS查询响应时间，会减少并行下载数量，可能会增加响应时间

方案：一个页面所产生的域名数最好不超过5个

- CDN(内容分布网络)

优点：可以给用户提供更快的响应速度，降低网络响应时间

问题：费用昂贵，烧钱

**<font color="blue">2、传输层面</font>**

1.减少http请求数量

- 內联CSS、JavaScript
描述：每次HTML文档被请求时，JavaScript和CSS都会内联在下载好的HTML文档，可以减少HTTP请求数目，但会增加了HTML的大小

优点：减少http请求

问题：內联代码无法缓存，重复访问都会请求，增加请求页面大小

方案：首次访问后，根据某种策略异步加载进行缓存，再次访问不內联，需要服务端支持

- CSS和JavaScript文件合并；
- 雪碧图
- 应避302、301、404、500等请求
- 避免空的src
- 可以使用CSS/SVG/ICON Font替代图片
- 制作更小的favicon.icon且可缓存

描述：每次favicon图片被请求，cookie都会被带上，所以需要放到一个不带cookie的域名上

2.降低请求数量

- Gzip压缩

Gzip压缩通常可以减小70%响应报头大小，且大部分浏览器都支持Gzip压缩

- 压缩JavaScript和CSS代码
- 减少cookie大小

描述：静态资源使用无Cookie域

方案：如果你的域名是`www.example.org`，你可以将静态资源托管在`static.example.org`。如果你已经在顶级域名`example.org`设置了cookies而不是在`www.example.org`，然后向`static.example.org`发送的请求都包含这些cookies。这种情况需要新搞一个静态域名

- 启用webp

描述：可以在页面加载时进行环境探测，可以根据从客户端获取的网络情况替换页面所使用的图片资源(压缩、裁减)

- 缩减服务端接口数据量和请求数量
- 在HTML里不要缩放图片

描述：请求实际大小的图片，而不是在HTML页面进行压缩

**<font color="blue">3、执行层面</font>**

##### 几个概念

- 关键：绝对需要
- 渲染：显示或者展示（在我们的情境中，网页经过渲染才能呈现给用户）
- 路径：使我们的网页展示在浏览器中的一系列事件
- 首屏：是用户滚动页面之前就能看见的部分
- 渲染路径：一系列使你的网页呈现在浏览器中的事件
- 关键渲染路径：呈现网页首屏所需的那些事件，因为几乎所有网站在渲染网页时都包含了不必要的步骤，而减少这些不必要的路径，能使你的网页加载速度提高几秒钟，这也是执行层面提高网页速度的最快方法

##### 最优渲染路径的三个指标：

- 最小化关键资源的数量
- 最小化关键字节数
- 最小化关键路径的长度

页面加载速度并不是指加载一个网页的总时间。它们说的是用户看到首屏所需的时间，以及用户可以开始与页面内容进行交互所需的时间

- 样式放在HEAD标签里面可以使得网页逐步渲染，减少重绘和回流
- 将脚本放在网页底部，不会阻塞页面渲染
- 避免CSS表达式
- 移除冗余代码

描述：代码冗余是首屏载入速度最大的拦路虎，是历史形成的包袱，只要能消除冗余，便能在后面的路走的更顺畅

问题：解决冗余便抛开了历史的包袱，是前端优化的第一步也是比较难的一步，但模块拆分也将全站分成了很多小的模块，载入的资源分散会增加请求数；如果全部合并，会导致首屏加载不需要的资源，也会导致下一个页面不能使用缓存

解决方案：如何做出合理的入口资源加载规则，如何合理的善用缓存，是优化的第二步

- 减少页面layout次数
	- 1.通过JavaScript获取需要计算的DOM属性
    - 2.添加或删除DOM元素
    - 3.resize浏览器窗口大小
    - 4.改变字体
    - 5.CSS伪类的激活，比如:hover
    - 6.通过JavaScript修改DOM元素样式且该样式涉及到尺寸的改变

- 使用requestAnimationFrame
- DOM读取最小化

描述：访问后的元素应缓存 更新offline节点然后将节点添加到DOM树

- 首屏加载、按需加载、第三方资源异步加载、Lazyload
- 避免大量的style
- 单页应用

描述：需要业务层级的支持，优化业务流程，减少http请求

- 资源离线、本地数据持久化

两个前提

	1.对于静态组件通过设置未来响应报头中的过期请求头来实现永不过期
	2.对于动态组件使用合适的可控制缓存的请求头来帮助浏览器实现条件化的请求

- 静态资源本地化localStorage、充分利用缓存技术减少网络成本，加快访问速度

描述：首次加载页面不可避免，还会请求网络，服务端有更新的时候，客户端不能够快速感知，页面可能还停留在一个旧的版本，尤其是网络速度较慢时，可能还是需要经过好几秒，页面才会更新至最新版本。因此如果应用对数据的新旧很敏感的话，这种方案就不适合

数据更新后，需要重新渲染界面，界面刷新的性能消耗比正常情况更多，而且增加了程序的复杂度，容易出错

对于一些时效性没有那么高的数据，可以考虑将接口数据缓存。那么页面的渲染将变成这样的流程：

![img1](https://github.com/slogeor/images/blob/master/fe/2018/06/01.png?raw=true)

而非首次进入界面，流程如下：

![img1](https://github.com/slogeor/images/blob/master/fe/2018/06/02.png?raw=true)

可以看出，在非首次进入界面的时候，页面不需要等待网络数据返回，就可以进行界面渲染，渲染的初始数据来自于本地的缓存，页面可以秒开。而当服务端的数据返回之后，本地的渲染会再次更新，缓存也被更新。

优点：首屏加载的速度简直太快了——静态资源来自本地，数据接口来自本地，这在2G、3G或者其他网络速度较慢的时候，也可以让用户在极短的时间内就看到内容

问题：数据更新后，需要重新渲染界面，界面刷新的性能消耗比正常情况更多，而且增加了程序的复杂度，容易出错；页面  可能还停留在一个旧的版本；版本控制、时间控制，当项目上线，如何让用户访问最新的资源

技术考虑：

- cookie被禁用
- localStorage被禁用
- localStorage被写满
- localStorage数据损坏
- 需要有一套完善的机制确保代码修改时能更新用户本地localStorage

方案：最好在服务端存一下每个用户拥有哪些资源，分别是什么版本，这样可以精准的更新指定代码，任务量会比较大

- bigrender

一个页面可能有多屏，首先出现在用户视野里应该是第一屏。其思路：

    1.先渲染首屏的内容，其余部分的html先被注释，可以保证不被渲染，减少首屏时间
    2.查看此屏内容，再触发脚步渲染dom，依次展现整个网页

- bigPipe

bigPipe对服务器要求比较高，需要支持chunk输出。其思路：将页面分为多个屏，每个屏都会对应一些数据，当其中一屏数据获取成功，就返回浏览器，且支持并行输出，这样就会减少浏览器等待时间

- 服务端
    1.接口合并，减少请求接口数量
    2.减少接口数据量
    3.接口数据缓存

### 参考链接

- [http://www.w3ctech.com/topic/1450](http://www.w3ctech.com/topic/1450)
- [http://www.w3ctech.com/topic/1416](http://www.w3ctech.com/topic/1416)
- [http://ddtalk.github.io/blog/2015/09/07/dingding-first/](http://ddtalk.github.io/blog/2015/09/07/dingding-first/)
- [http://www.w3ctech.com/topic/1084](http://www.w3ctech.com/topic/1084)
- [http://www.cnblogs.com/leefreeman/p/3998757.html](http://www.cnblogs.com/leefreeman/p/3998757.html)
- [http://tgideas.qq.com/webplat](http://tgideas.qq.com/webplat/info/news_version3/804/7104/7106/m5723/201507/361457.shtml#rd)
- [http://www.orrafy.com/posts/web-dev/quickling-1/](http://www.orrafy.com/posts/web-dev/quickling-1/)

### BigPape

- [https://github.com/tangguangyao/bigpipe](https://github.com/tangguangyao/bigpipe)
- [http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html](http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html)
- [http://huoding.com/2011/06/26/88](http://huoding.com/2011/06/26/88)
